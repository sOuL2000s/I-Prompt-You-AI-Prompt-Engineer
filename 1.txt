codebase 1 : 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Prompt U - Expert AI Prompt Engineer</title>
    <link rel="stylesheet" href="style.css">
    <!-- Using a simple emoji as favicon for a modern, minimal aesthetic -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ú®</text></svg>">
    <!-- Google Fonts: Inter for body text (clean sans-serif), Roboto Mono for code/input (monospaced) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header>
            <h1>I Prompt U <span class="emoji">‚ú®</span></h1>
            <p class="tagline">Your Expert AI Prompt Engineer</p>
        </header>

        <section class="card input-section">
            <label for="userInput" class="section-title">Your Raw Idea / Content:</label>
            <textarea id="userInput" placeholder="Type, speak, or upload your raw idea, task, or content here..."></textarea>
            
            <div class="input-controls">
                <!-- Voice Input Button -->
                <button id="voiceInputBtn" class="action-btn icon-btn">
                    <span class="icon">üé§</span>
                    <span class="btn-text">Speak Idea</span>
                </button>
                
                <!-- File Upload Mechanism -->
                <div class="file-upload-wrapper">
                    <!-- Hidden file input to allow broad selection -->
                    <input type="file" id="fileInput" accept="
                        text/*,
                        .txt,.md,.js,.py,.json,.html,.css,.xml,.csv,.log,.sh,.rb,.go,.java,.cpp,.c,.h,.swift,.kt,.php,.ts,.tsx,.jsx,.scss,.less,.yaml,.ini,.cfg,.toml,.rtf,
                        image/*,.jpg,.jpeg,.png,.gif,.webp,.svg,
                        application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,
                        application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,
                        application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation
                    " style="display: none;">
                    <!-- Visible button to trigger hidden file input -->
                    <button id="uploadFileBtn" class="action-btn icon-btn">
                        <span class="icon">üìÅ</span>
                        <span class="btn-text">Upload File</span>
                    </button>
                    <!-- Display for selected file name -->
                    <span id="fileNameDisplay" class="file-name-display">No file chosen</span>
                </div>
            </div>
            <!-- Preview area for uploaded images -->
            <div id="filePreview" class="file-preview"></div>
            <small class="file-info-text">Supported: Text, Code, Plain Documents (content extracted for text), Images (for multimodal AI). Audio/Video/Complex Docs require manual description or a backend service.</small>
        </section>

        <!-- Main action button -->
        <button id="generatePromptBtn" class="primary-btn">Generate AI Prompt</button>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading" style="display: none;">
            <div class="spinner"></div>
            <span>Crafting your prompt...</span>
        </div>

        <!-- Error Message Display -->
        <div id="errorMessage" class="error-message" style="display: none;"></div>

        <section class="card output-section">
            <label for="outputPrompt" class="section-title">Refined Prompt for AI:</label>
            <!-- Output textarea for the generated prompt -->
            <textarea id="outputPrompt" readonly placeholder="Your well-structured prompt will appear here..."></textarea>
            <!-- Copy button for the generated prompt -->
            <button id="copyPromptBtn" class="action-btn icon-btn" style="display: none;">
                <span class="icon">üìã</span>
                <span class="btn-text">Copy Prompt</span>
            </button>
        </section>
    </div>

    <script src="script.js"></script>
</body>
</html>

// WARNING: This API key is exposed in client-side code.
// For a production application, you MUST use a backend server to
// securely store and access your API key.
const GEMINI_API_KEY = "AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA";
const GEMINI_MODEL = "gemini-2.5-flash-preview-05-20"; // As specified
const API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

// Get DOM elements
const userInput = document.getElementById('userInput');
const voiceInputBtn = document.getElementById('voiceInputBtn');
const fileInput = document.getElementById('fileInput');
const uploadFileBtn = document.getElementById('uploadFileBtn');
const fileNameDisplay = document.getElementById('fileNameDisplay');
const filePreview = document.getElementById('filePreview');
const generatePromptBtn = document.getElementById('generatePromptBtn');
const loadingIndicator = document.getElementById('loadingIndicator');
const errorMessage = document.getElementById('errorMessage');
const outputPrompt = document.getElementById('outputPrompt');
const copyPromptBtn = document.getElementById('copyPromptBtn');

// State variables for file uploads, particularly for images
let attachedImageBase64 = null;
let attachedImageMimeType = null;

// --- Helper Functions for UI State Management ---
function showLoading() {
    loadingIndicator.style.display = 'flex';
    generatePromptBtn.disabled = true;
    voiceInputBtn.disabled = true;
    uploadFileBtn.disabled = true;
    copyPromptBtn.style.display = 'none'; // Hide copy button while loading
    outputPrompt.value = ''; // Clear previous output
    clearError();
}

function hideLoading() {
    loadingIndicator.style.display = 'none';
    generatePromptBtn.disabled = false;
    voiceInputBtn.disabled = false;
    uploadFileBtn.disabled = false;
    checkGenerateButtonState(); // Re-enable generate button based on current input
}

function showError(message) {
    errorMessage.innerHTML = `‚ö†Ô∏è ${message}`; // Add emoji for visual cue
    errorMessage.style.display = 'flex'; // Use flex for icon alignment
}

function clearError() {
    errorMessage.textContent = '';
    errorMessage.style.display = 'none';
}

function showCopyButton() {
    if (outputPrompt.value.trim() !== '') {
        copyPromptBtn.style.display = 'flex'; // Use flex for icon and text alignment
    }
}

function clearFileInputState() {
    fileInput.value = ''; // Clear the file input element itself
    fileNameDisplay.textContent = 'No file chosen';
    filePreview.innerHTML = '';
    filePreview.style.display = 'none';
    attachedImageBase64 = null;
    attachedImageMimeType = null;
    checkGenerateButtonState(); // Update generate button state
}

// Check if generate button should be enabled
function checkGenerateButtonState() {
    if (userInput.value.trim() !== '' || attachedImageBase64 !== null) {
        generatePromptBtn.disabled = false;
    } else {
        generatePromptBtn.disabled = true;
    }
}

// --- Main Logic: Generate Prompt (Multimodal Support) ---
async function generatePrompt() {
    let inputText = userInput.value.trim();

    if (!inputText && !attachedImageBase64) {
        showError("Please enter some text, speak your idea, or upload a file (text/image).");
        return;
    }

    showLoading();

    try {
        // System instruction for the AI prompt engineer
        const systemInstruction = `
            You are an expert AI prompt engineer named "I Prompt U".
            Your task is to take the user's raw input (text, voice transcript, or file content, potentially including an image) and convert it into a well-structured, clear, concise, and highly effective prompt suitable for another AI model to understand and execute a specific task.

            Consider the following aspects when refining the prompt:
            1.  **Clarity & Precision:** Ensure the intent is unambiguous and all terms are precisely defined if necessary.
            2.  **Specificity:** Include all necessary details, constraints, and requirements for the task.
            3.  **Context & Background:** Provide sufficient background information for the AI to understand the situation.
            4.  **Desired Output Format:** Specify the expected format (e.g., list, JSON, paragraph, code snippet, specific tone, length).
            5.  **Role Assignment (for the target AI):** If appropriate, suggest a persona or role for the target AI to adopt (e.g., "Act as a senior marketing specialist...").
            6.  **Examples (if applicable):** If the input implies a need for examples, suggest that the user might add them, or structure the prompt to accommodate them.

            Your output should be *only* the refined prompt. Do not add conversational filler, intros, or outros. Focus solely on producing the optimal prompt for the user's intent.
        `;

        // Construct the parts for the Gemini API request
        const requestParts = [
            { text: systemInstruction },
        ];

        if (inputText) {
            requestParts.push({ text: `User's initial textual input: "${inputText}"` });
        }

        if (attachedImageBase64 && attachedImageMimeType) {
            requestParts.push({
                inlineData: {
                    mimeType: attachedImageMimeType,
                    data: attachedImageBase64
                }
            });
            // Add a instruction to Gemini to consider the image
            requestParts.push({ text: `Carefully analyze the provided image in conjunction with the user's textual request to formulate the most effective prompt.` });
        }

        const response = await fetch(API_BASE_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [
                    {
                        parts: requestParts
                    }
                ]
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
        }

        const data = await response.json();
        // Ensure that the response structure is as expected
        if (data.candidates && data.candidates.length > 0 && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
            const generatedText = data.candidates[0].content.parts[0].text;
            outputPrompt.value = generatedText.trim();
            showCopyButton();
        } else {
            throw new Error("No prompt generated. The AI might have refused, produced empty output, or encountered an internal issue.");
        }

    } catch (error) {
        console.error('Error generating prompt:', error);
        showError(`Failed to generate prompt: ${error.message}. Please try again.`);
        outputPrompt.value = "Failed to generate prompt. Please check your input or try again later.";
    } finally {
        hideLoading();
    }
}

// --- Event Listeners ---
generatePromptBtn.addEventListener('click', generatePrompt);

// Voice Input (Speech Recognition)
voiceInputBtn.addEventListener('click', () => {
    // Check browser compatibility
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        showError("Your browser does not fully support Speech Recognition (e.g., Chrome, Edge, Firefox). Please use text input.");
        return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();

    recognition.lang = 'en-US'; // Set language
    recognition.interimResults = false; // Only return final results
    recognition.maxAlternatives = 1; // Only the most likely result

    voiceInputBtn.innerHTML = '<span class="icon">üéß</span> <span class="btn-text">Listening...</span>';
    voiceInputBtn.disabled = true;
    generatePromptBtn.disabled = true;
    clearError();
    clearFileInputState(); // Clear any attached files when voice input is initiated

    recognition.start();

    recognition.onresult = (event) => {
        const speechResult = event.results[0][0].transcript;
        userInput.value = speechResult;
        voiceInputBtn.innerHTML = '<span class="icon">üé§</span> <span class="btn-text">Speak Idea</span>';
        voiceInputBtn.disabled = false;
        checkGenerateButtonState(); // Re-enable generate button
    };

    recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        showError(`Speech recognition error: ${event.error}. Please try again.`);
        voiceInputBtn.innerHTML = '<span class="icon">üé§</span> <span class="btn-text">Speak Idea</span>';
        voiceInputBtn.disabled = false;
        checkGenerateButtonState(); // Re-enable generate button
    };

    recognition.onend = () => {
        // This fires when recognition stops, regardless of success.
        // Only reset button text if it's still "Listening..." and no new speech was captured.
        if (voiceInputBtn.textContent.includes('Listening')) {
           voiceInputBtn.innerHTML = '<span class="icon">üé§</span> <span class="btn-text">Speak Idea</span>';
           voiceInputBtn.disabled = false;
           checkGenerateButtonState(); // Re-enable generate button
        }
    };
});

// File Upload
uploadFileBtn.addEventListener('click', () => {
    fileInput.click(); // Programmatically click the hidden file input
});

fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) {
        clearFileInputState();
        return;
    }

    fileNameDisplay.textContent = file.name;
    clearError();
    filePreview.innerHTML = ''; // Clear previous preview
    filePreview.style.display = 'none';

    // File type detection logic
    const isTextFile = file.type.startsWith('text/') ||
                       /\.(txt|md|js|py|json|html|css|xml|csv|log|sh|rb|go|java|cpp|c|h|swift|kt|php|ts|tsx|jsx|scss|less|yaml|ini|cfg|toml|rtf)$/i.test(file.name);
    
    // Common document formats that are NOT easily parsable client-side for content extraction
    const isComplexDocument = /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i.test(file.name);
    
    const isImageFile = file.type.startsWith('image/');
    const isAudioVideoFile = file.type.startsWith('audio/') || file.type.startsWith('video/');

    // Implement a reasonable client-side file size limit (e.g., 5MB)
    const MAX_FILE_SIZE_MB = 5;
    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
        showError(`File is too large. Max ${MAX_FILE_SIZE_MB}MB for direct processing. For larger files, please provide a summary in the text input or consider a backend service.`);
        clearFileInputState();
        return;
    }

    const reader = new FileReader();

    reader.onload = (e) => {
        if (isTextFile) {
            userInput.value = e.target.result;
            attachedImageBase64 = null; // Clear image if text file is uploaded
            attachedImageMimeType = null;
            filePreview.style.display = 'none';
        } else if (isImageFile) {
            userInput.value = ''; // Clear text input when an image is uploaded, user can then type their intent for the image
            // Extract base64 data part from the Data URL
            attachedImageBase64 = e.target.result.split(',')[1];
            attachedImageMimeType = file.type;
            
            // Create and display image preview
            const img = document.createElement('img');
            img.src = e.target.result;
            img.alt = `Preview of ${file.name}`;
            filePreview.appendChild(img);
            filePreview.style.display = 'flex'; // Show image preview container
        } else if (isAudioVideoFile || isComplexDocument) {
            showError(`Direct processing of "${file.name}" (${file.type}) is not supported client-side for content extraction. Please describe its content in the text box for the AI, or use a backend for full processing.`);
            clearFileInputState();
            userInput.value = ''; // Ensure text input is clear if an unsupported file type is "attached"
        }
        checkGenerateButtonState(); // Update generate button state after file processing
    };

    reader.onerror = (e) => {
        console.error("File reading error:", e);
        showError("Failed to read file. Please try again.");
        clearFileInputState();
    };

    // Read the file based on its type
    if (isTextFile) {
        reader.readAsText(file);
    } else if (isImageFile) {
        reader.readAsDataURL(file); // For images, read as Data URL for base64 encoding
    } else if (isAudioVideoFile || isComplexDocument) {
        // For unsupported types, we don't read them but inform the user and clear state
        clearFileInputState();
    }
});

// Copy to Clipboard
copyPromptBtn.addEventListener('click', async () => {
    try {
        await navigator.clipboard.writeText(outputPrompt.value);
        const originalContent = copyPromptBtn.innerHTML;
        copyPromptBtn.innerHTML = '<span class="icon">‚úÖ</span> <span class="btn-text">Copied!</span>';
        setTimeout(() => {
            copyPromptBtn.innerHTML = originalContent;
        }, 2000);
    } catch (err) {
        console.error('Failed to copy text: ', err);
        showError('Failed to copy prompt to clipboard. Please copy manually.');
    }
});

// Event listeners for input changes to enable/disable generate button
userInput.addEventListener('input', checkGenerateButtonState);
// No need for fileInput.addEventListener('change', checkGenerateButtonState) directly
// as it's called within the change handler already.

// Initial check on page load
checkGenerateButtonState();

/* Import Google Fonts for Inter and Roboto Mono */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono:wght@400&display=swap');

/* CSS Variables for a consistent and easily changeable theme */
:root {
    --primary-color: #6C63FF; /* Vibrant Violet */
    --primary-light: #8A81FF;
    --primary-dark: #504CB3;
    --accent-color: #FFA07A; /* Light Salmon for highlights, though sparingly used here */
    --text-color: #333333;
    --text-light: #666666;
    --bg-color: #F8F9FA; /* Off-white background */
    --card-bg: #FFFFFF; /* White card background */
    --border-color: #E0E0E0; /* Light gray border */
    --error-color: #DC3545; /* Red for errors */
    --success-color: #28A745; /* Green for success */
    --shadow-light: rgba(0, 0, 0, 0.05); /* Light shadow for subtle depth */
    --shadow-medium: rgba(0, 0, 0, 0.1); /* Medium shadow for main container */

    --border-radius-base: 12px;
    --padding-base: 25px;
}

body {
    font-family: 'Inter', sans-serif;
    margin: 0;
    padding: 20px;
    background-color: var(--bg-color);
    color: var(--text-color);
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Align content to the top */
    min-height: 100vh; /* Ensure full viewport height */
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    line-height: 1.6; /* Improved readability */
}

.container {
    background-color: var(--card-bg);
    border-radius: var(--border-radius-base);
    box-shadow: 0 10px 30px var(--shadow-medium); /* Prominent shadow for the main container */
    padding: var(--padding-base);
    max-width: 900px;
    width: 100%;
    text-align: center;
    border-top: 6px solid var(--primary-color); /* Signature top border */
    display: flex;
    flex-direction: column;
    gap: 25px; /* Spacing between main sections */
}

header {
    margin-bottom: 20px;
}

h1 {
    color: var(--primary-color);
    font-size: 3em;
    margin-bottom: 5px;
    font-weight: 700;
}

.emoji {
    font-size: 0.9em; /* Adjust emoji size */
}

.tagline {
    font-size: 1.25em;
    color: var(--text-light);
    font-weight: 400;
    margin-top: 0;
}

/* Card styling for sections */
.card {
    background-color: var(--card-bg);
    border-radius: var(--border-radius-base);
    box-shadow: 0 4px 15px var(--shadow-light); /* Subtle shadow for inner cards */
    padding: var(--padding-base);
    text-align: left; /* Align content inside card to left */
}

.section-title {
    display: block;
    font-size: 1.2em;
    font-weight: 600;
    color: var(--primary-dark);
    margin-bottom: 15px;
}

textarea {
    width: 100%;
    min-height: 160px;
    padding: 15px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-family: 'Roboto Mono', monospace; /* Monospaced font for code-like input */
    font-size: 1em;
    resize: vertical; /* Allow vertical resizing */
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    box-sizing: border-box; /* Include padding in width calculation */
}

textarea:focus {
    border-color: var(--primary-color);
    outline: none;
    box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.2); /* Focus ring effect */
}

.input-controls {
    display: flex;
    flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
    gap: 15px;
    margin-top: 20px;
    margin-bottom: 15px;
    justify-content: flex-start; /* Align items to the start */
}

button {
    padding: 12px 25px;
    border: none;
    border-radius: 8px;
    font-size: 1.05em;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px; /* Spacing between icon and text */
}

.icon-btn .icon {
    font-size: 1.2em; /* Larger icons */
}

/* Primary Button Styling */
.primary-btn {
    background-color: var(--primary-color);
    color: #fff;
    box-shadow: 0 4px 10px rgba(108, 99, 255, 0.3);
    align-self: center; /* Center the button in the container */
}

.primary-btn:hover {
    background-color: var(--primary-light);
    transform: translateY(-2px); /* Lift effect on hover */
    box-shadow: 0 6px 15px rgba(108, 99, 255, 0.4);
}

.primary-btn:active {
    transform: translateY(0); /* Reset on click */
    box-shadow: 0 2px 5px rgba(108, 99, 255, 0.3);
}

.primary-btn:disabled {
    background-color: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Secondary Action Button Styling */
.action-btn {
    background-color: var(--border-color); /* Lighter background */
    color: var(--text-color);
}

.action-btn:hover {
    background-color: #d0d0d0; /* Slightly darker */
    transform: translateY(-2px);
    box-shadow: 0 2px 5px var(--shadow-light);
}

.action-btn:active {
    transform: translateY(0);
    box-shadow: none;
}

.action-btn:disabled {
    background-color: #e0e0e0;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.file-upload-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-grow: 1; /* Allow wrapper to take available space */
    max-width: 100%; /* Prevent overflow */
}

.file-name-display {
    font-size: 0.95em;
    color: var(--text-light);
    white-space: nowrap; /* Prevent wrapping */
    overflow: hidden;
    text-overflow: ellipsis; /* Show ellipsis if text overflows */
    max-width: 150px; /* Limit width */
}

.file-info-text {
    color: var(--text-light);
    display: block;
    margin-top: 5px;
    font-size: 0.9em;
}

.file-preview {
    margin-top: 15px;
    max-width: 100%;
    max-height: 200px; /* Limit height */
    overflow: hidden; /* Hide overflow if image is too large */
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px dashed var(--border-color);
    border-radius: 8px;
    padding: 10px;
    display: none; /* Hidden by default */
}

.file-preview img {
    max-width: 100%;
    max-height: 180px; /* Adjust height within preview box */
    border-radius: 6px;
    object-fit: contain; /* Ensure image fits within bounds without cropping */
}

/* Loading Indicator Styling */
.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin: 25px 0;
    color: var(--primary-color);
    font-size: 1.2em;
    font-weight: 600;
}

.spinner {
    border: 4px solid rgba(108, 99, 255, 0.3);
    border-top: 4px solid var(--primary-color);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Error Message Styling */
.error-message {
    color: var(--error-color);
    background-color: #fce8e9; /* Light red background */
    border: 1px solid var(--error-color);
    padding: 12px;
    border-radius: 8px;
    margin: 25px 0;
    font-weight: 500;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 10px;
}

.error-message::before {
    content: '‚ö†Ô∏è'; /* Warning emoji for visual emphasis */
    font-size: 1.2em;
    flex-shrink: 0; /* Prevent emoji from shrinking */
}

/* Output Section Styling */
.output-section #outputPrompt {
    background-color: var(--bg-color); /* Slightly different background for output to distinguish */
    min-height: 200px;
    color: var(--text-color);
    border: 1px dashed var(--primary-light); /* Dashed border for generated content */
    margin-bottom: 15px;
}

.output-section #copyPromptBtn {
    float: right; /* Align copy button to the right */
    margin-top: 0;
}

/* --- Responsive Adjustments --- */
@media (max-width: 768px) {
    .container {
        padding: 20px;
        margin: 15px;
        gap: 20px;
    }
    h1 {
        font-size: 2.5em;
    }
    .tagline {
        font-size: 1.1em;
    }
    .card {
        padding: 20px;
    }
    .section-title {
        font-size: 1.1em;
    }
    textarea {
        min-height: 120px;
        padding: 12px;
    }
    .input-controls {
        flex-direction: column; /* Stack buttons vertically */
        gap: 10px;
    }
    .file-upload-wrapper {
        flex-direction: row; /* Keep button and name display inline */
        justify-content: flex-start;
        align-items: center;
    }
    .file-name-display {
        max-width: calc(100% - 150px); /* Adjust width for smaller screens */
        flex-grow: 1;
    }
    button {
        padding: 10px 20px;
        font-size: 1em;
        width: 100%; /* Make buttons full width in input-controls */
    }
    .file-upload-wrapper button {
        width: auto; /* Reset for file upload button inside wrapper */
        flex-shrink: 0;
    }
    .output-section #copyPromptBtn {
        float: none; /* Stack copy button below output */
        width: 100%;
        margin-top: 10px;
    }
}

@media (max-width: 480px) {
    body {
        padding: 10px;
    }
    .container {
        padding: 15px;
        margin: 0;
        border-radius: 8px;
        border-top-width: 4px;
        gap: 15px;
    }
    h1 {
        font-size: 2em;
    }
    .tagline {
        font-size: 0.95em;
    }
    .card {
        padding: 15px;
    }
    .section-title {
        font-size: 1em;
    }
    textarea {
        min-height: 100px;
        font-size: 0.9em;
    }
    button {
        font-size: 0.95em;
        padding: 10px 15px;
        gap: 5px;
    }
    .file-name-display {
        font-size: 0.85em;
        max-width: 100px; /* Further limit width */
    }
    .spinner {
        width: 25px;
        height: 25px;
    }
    .loading span {
        font-size: 1em;
    }
    .error-message {
        font-size: 0.9em;
        padding: 10px;
    }
}

-------------------------------------------------------------------------------------

codebase 2: 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Prompt You - AI Prompt Engineer</title>
    <!-- Google Fonts: Space Grotesk for headings, Noto Sans for body text -->
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&family=Noto+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <!-- Using a simple emoji as favicon for a modern, minimal aesthetic -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ú®</text></svg>">
</head>
<body>
    <header class="main-header">
        <div class="logo">
            <span class="logo-icon">‚ú®</span>
            <span class="logo-text">I Prompt You</span>
        </div>
        <nav class="main-nav">
            <ul>
                <li><a href="#home">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#examples">Examples</a></li>
                <li><a href="#contact-section">Contact</a></li>
            </ul>
        </nav>
        <div class="header-actions">
            <button id="viewHistoryBtn" class="action-btn header-btn">View History</button>
            <button id="newPromptRefreshBtn" class="primary-btn header-btn">New Prompt</button>
        </div>
    </header>

    <main>
        <section class="hero-section" id="home">
            <div class="hero-content">
                <h1>Generate AI Prompts with Ease</h1>
                <h2>Input your desired output, and our AI will craft the perfect prompt for other AI models.</h2>
                <div class="prompt-input-area">
                    <div class="input-field-group">
                        <span class="icon search-icon">üîç</span>
                        <textarea id="userInput" placeholder="Describe your desired output here..."></textarea>
                        <button id="generatePromptBtn" class="generate-btn primary-btn">Generate Prompt</button>
                    </div>

                    <div class="additional-input-controls">
                        <div class="file-upload-wrapper">
                            <input type="file" id="fileInput" multiple accept="
                                text/*, .txt,.md,.js,.py,.json,.html,.css,.xml,.csv,.log,.sh,.rb,.go,.java,.cpp,.c,.h,.swift,.kt,.php,.ts,.tsx,.jsx,.scss,.less,.yaml,.ini,.cfg,.toml,.rtf,
                                image/*,.jpg,.jpeg,.png,.gif,.webp,.svg,
                                application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,
                                application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,
                                application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation
                            " style="display: none;">
                            <button id="uploadFileBtn" class="action-btn icon-btn">
                                <span class="icon">üìÅ</span>
                                <span class="btn-text">Upload Files</span>
                            </button>
                            <span id="fileNameDisplay" class="file-name-display">No files chosen</span>
                        </div>
                        <button id="voiceInputBtn" class="action-btn icon-btn">
                            <span class="icon">üé§</span>
                            <span class="btn-text">Speak Idea</span>
                        </button>
                    </div>

                    <div id="filePreview" class="file-preview"></div>
                    <small class="file-info-text">Supported: Text, Code, Plain Documents (content extracted for text), Images (for multimodal AI). Audio/Video/Complex Docs require manual description or a backend service.</small>

                    <div id="loadingIndicator" class="loading" style="display: none;">
                        <div class="spinner"></div>
                        <span>Crafting your prompt...</span>
                    </div>
                    <div id="errorMessage" class="error-message" style="display: none;"></div>
                </div>

                <div class="output-section">
                    <label for="outputPrompt" class="section-title">Refined Prompt for AI:</label>
                    <textarea id="outputPrompt" readonly placeholder="Your well-structured prompt will appear here..."></textarea>
                    <button id="copyPromptBtn" class="action-btn icon-btn" style="display: none;">
                        <span class="icon">üìã</span>
                        <span class="btn-text">Copy Prompt</span>
                    </button>
                </div>
            </div>
        </section>

        <section class="section-cards" id="examples">
            <h2 class="section-heading">Example Prompts</h2>
            <div class="example-grid">
                <div class="example-card">
                    <span class="icon">‚ú®</span>
                    <p>Write a short story about a talking cat</p>
                </div>
                <div class="example-card">
                    <span class="icon">üìù</span>
                    <p>Summarize this article for a 5th grader</p>
                </div>
                <div class="example-card">
                    <span class="icon">ü§ñ</span>
                    <p>Generate Python code for a simple web server</p>
                </div>
            </div>
        </section>

        <section class="section-text" id="about">
            <h2 class="section-heading">What is Prompt Engineering?</h2>
            <p>Prompt engineering is the process of designing and refining inputs (prompts) for AI models to achieve desired outputs. It involves understanding how AI models process information and crafting instructions that leverage their capabilities effectively. A well-engineered prompt can drastically improve the relevance, quality, and accuracy of AI-generated content, moving from generic responses to highly specific, useful, and creative results. It's about speaking the AI's language to unlock its full potential.</p>
        </section>

        <section id="contact-section" class="section-text" style="padding-bottom: 80px; text-align: center;">
            <h2 class="section-heading">Contact Us</h2>
            <p>Have questions or feedback? Reach out to us at support@ipromptyou.com</p>
        </section>
    </main>

    <footer class="main-footer">
        <nav class="footer-nav">
            <ul>
                <li><a href="#">Terms of Service</a></li>
                <li><a href="#">Privacy Policy</a></li>
                <li><a href="#">Contact Us</a></li>
            </ul>
        </nav>
        <p class="copyright">&copy; 2024 I Prompt You. All rights reserved.</p>
    </footer>

    <!-- History Modal -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 class="modal-title">Prompt History</h2>
            <div id="historyList" class="history-list">
                <p class="no-history-message">No prompts saved yet. Generate a prompt to see it here!</p>
            </div>
            <div class="modal-actions">
                <button id="clearHistoryBtn" class="action-btn">Clear All History</button>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>

// WARNING: This API key is exposed in client-side code.
// For a production application, you MUST use a backend server to
// securely store and access your API key.
const GEMINI_API_KEY = "AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA";
const GEMINI_MODEL = "gemini-2.5-flash-preview-05-20";
const API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;

// Get DOM elements
const userInput = document.getElementById('userInput');
const voiceInputBtn = document.getElementById('voiceInputBtn');
const fileInput = document.getElementById('fileInput');
const uploadFileBtn = document.getElementById('uploadFileBtn');
const fileNameDisplay = document.getElementById('fileNameDisplay');
const filePreview = document.getElementById('filePreview');
const generatePromptBtn = document.getElementById('generatePromptBtn');
const loadingIndicator = document.getElementById('loadingIndicator');
const errorMessage = document.getElementById('errorMessage');
const outputPrompt = document.getElementById('outputPrompt');
const copyPromptBtn = document.getElementById('copyPromptBtn');

// New/Modified DOM elements for header actions
const newPromptRefreshBtn = document.getElementById('newPromptRefreshBtn');
const viewHistoryBtn = document.getElementById('viewHistoryBtn');

// DOM elements for history modal
const historyModal = document.getElementById('historyModal');
const closeHistoryBtn = historyModal.querySelector('.close-button');
const historyList = document.getElementById('historyList');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');

// State variables
let attachedFiles = []; // Array to store objects like { id: string, type: 'text'|'image', content: string|base64, mimeType?: string, fileName: string, size: number }
let voiceRecognitionActive = false; // To manage voice input state
let recognition; // Keep recognition object in a broader scope to stop it externally


// --- Helper Functions for UI State Management ---
function showLoading() {
    loadingIndicator.style.display = 'flex';
    generatePromptBtn.disabled = true;
    voiceInputBtn.disabled = true;
    uploadFileBtn.disabled = true;
    userInput.disabled = true; // Disable manual input during loading
    copyPromptBtn.style.display = 'none'; // Hide copy button while loading
    outputPrompt.value = ''; // Clear previous output
    clearError();
}

function hideLoading() {
    loadingIndicator.style.display = 'none';
    // Only disable userInput/uploadFileBtn if voice is actively listening
    userInput.disabled = voiceRecognitionActive;
    uploadFileBtn.disabled = voiceRecognitionActive;
    voiceInputBtn.disabled = false; // Always allow starting/stopping voice recognition
    checkGenerateButtonState(); // Re-enable generate button based on current input
}

function showError(message) {
    errorMessage.innerHTML = `‚ö†Ô∏è ${message}`; // Add emoji for visual cue
    errorMessage.style.display = 'flex'; // Use flex for icon alignment
}

function clearError() {
    errorMessage.textContent = '';
    errorMessage.style.display = 'none';
}

function showCopyButton() {
    if (outputPrompt.value.trim() !== '') {
        copyPromptBtn.style.display = 'flex'; // Use flex for icon and text alignment
    }
}

function generateUniqueId() {
    return 'file-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

function addFileToState(fileData) {
    const newFile = {
        id: generateUniqueId(),
        ...fileData
    };
    attachedFiles.push(newFile);
    // UI rendering and button state update are handled after all files are processed
}

function removeFileFromState(fileId) {
    attachedFiles = attachedFiles.filter(f => f.id !== fileId);
    renderFilePreviews(); // Re-render previews after removal
    checkGenerateButtonState(); // Update generate button state
}

function clearFileInputState() {
    fileInput.value = ''; // Clear the file input element itself
    fileNameDisplay.textContent = 'No files chosen';
    filePreview.innerHTML = '';
    filePreview.classList.remove('active'); // Hide preview container
    attachedFiles = [];
    checkGenerateButtonState(); // Update generate button state
}

function renderFilePreviews() {
    filePreview.innerHTML = '';
    if (attachedFiles.length === 0) {
        filePreview.classList.remove('active');
        fileNameDisplay.textContent = 'No files chosen';
        return;
    }

    filePreview.classList.add('active');
    fileNameDisplay.textContent = `${attachedFiles.length} file(s) chosen`;

    attachedFiles.forEach(file => {
        const item = document.createElement('div');
        item.className = 'file-preview-item';
        item.dataset.fileId = file.id;

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-file-btn';
        removeBtn.innerHTML = '√ó';
        removeBtn.onclick = (e) => {
            e.stopPropagation();
            removeFileFromState(file.id);
        };
        item.appendChild(removeBtn);

        if (file.type === 'image') {
            const img = document.createElement('img');
            img.src = `data:${file.mimeType};base64,${file.content}`;
            img.alt = `Preview of ${file.fileName}`;
            item.appendChild(img);
        } else { // Text or other file types we've extracted content from
            const icon = document.createElement('span');
            icon.className = 'icon';
            icon.textContent = 'üìÑ'; // Text file icon
            icon.style.fontSize = '2em'; // Adjust icon size
            item.appendChild(icon);
        }

        const name = document.createElement('span');
        name.className = 'file-name';
        name.textContent = file.fileName;
        item.appendChild(name);

        const size = document.createElement('span');
        size.className = 'file-size';
        size.textContent = `${(file.size / 1024).toFixed(1)} KB`;
        item.appendChild(size);

        filePreview.appendChild(item);
    });
}


// Check if generate button should be enabled
function checkGenerateButtonState() {
    // Generate button is disabled if voice recognition is active, regardless of other inputs
    if (voiceRecognitionActive) {
        generatePromptBtn.disabled = true;
        return;
    }

    // Otherwise, enable if there's text or files
    if (userInput.value.trim() !== '' || attachedFiles.length > 0) {
        generatePromptBtn.disabled = false;
    } else {
        generatePromptBtn.disabled = true;
    }
}

// --- Main Logic: Generate Prompt (Multimodal Support) ---
async function generatePrompt() {
    let inputText = userInput.value.trim();

    if (!inputText && attachedFiles.length === 0) {
        showError("Please enter some text, speak your idea, or upload a file (text/image).");
        return;
    }

    showLoading();

    try {
        // System instruction for the AI prompt engineer
        const systemInstruction = `
            You are an expert AI prompt engineer named "I Prompt You".
            Your task is to take the user's raw input (text, voice transcript, or file content, potentially including multiple images and text files) and convert it into a well-structured, clear, concise, and highly effective prompt suitable for another AI model to understand and execute a specific task.

            Consider the following aspects when refining the prompt:
            1.  **Clarity & Precision:** Ensure the intent is unambiguous and all terms are precisely defined if necessary.
            2.  **Specificity:** Include all necessary details, constraints, and requirements for the task.
            3.  **Context & Background:** Provide sufficient background information for the AI to understand the situation.
            4.  **Desired Output Format:** Specify the expected format (e.g., list, JSON, paragraph, code snippet, specific tone, length).
            5.  **Role Assignment (for the target AI):** If appropriate, suggest a persona or role for the target AI to adopt (e.g., "Act as a senior marketing specialist...").
            6.  **Examples (if applicable):** If the input implies a need for examples, suggest that the user might add them, or structure the prompt to accommodate them.

            Your output should be *only* the refined prompt. Do not add conversational filler, intros, or outros. Focus solely on producing the optimal prompt for the user's intent.
        `;

        const requestParts = [{ text: systemInstruction }];

        if (inputText) {
            requestParts.push({ text: `User's primary textual input: "${inputText}"` });
        }

        const uploadedTextContent = [];
        const uploadedImageParts = [];

        attachedFiles.forEach(file => {
            if (file.type === 'text') {
                uploadedTextContent.push(`--- File: ${file.fileName} ---\n${file.content}`);
            } else if (file.type === 'image') {
                uploadedImageParts.push({
                    inlineData: {
                        mimeType: file.mimeType,
                        data: file.content
                    }
                });
            }
        });

        if (uploadedTextContent.length > 0) {
            requestParts.push({ text: `Additional textual context from uploaded files:\n${uploadedTextContent.join('\n\n')}` });
        }

        if (uploadedImageParts.length > 0) {
            if (uploadedImageParts.length > 10) {
                throw new Error("Too many images uploaded. Please limit to 10 images per prompt for optimal performance with Gemini API.");
            }
            uploadedImageParts.forEach(part => requestParts.push(part));
            requestParts.push({ text: `Carefully analyze the provided image(s) in conjunction with the user's textual request and any other uploaded text to formulate the most effective prompt.` });
        }
        
        const response = await fetch(API_BASE_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [
                    {
                        parts: requestParts
                    }
                ]
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
        }

        const data = await response.json();
        if (data.candidates && data.candidates.length > 0 && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
            const generatedText = data.candidates[0].content.parts[0].text;
            outputPrompt.value = generatedText.trim();
            showCopyButton();

            // Save to history upon successful generation
            const attachedFileNames = attachedFiles.map(f => f.fileName);
            savePromptToHistory(inputText, generatedText.trim(), attachedFileNames);

        } else {
            throw new Error("No prompt generated. The AI might have refused, produced empty output, or encountered an internal issue.");
        }

    } catch (error) {
        console.error('Error generating prompt:', error);
        showError(`Failed to generate prompt: ${error.message}. Please try again.`);
        outputPrompt.value = "Failed to generate prompt. Please check your input or try again later.";
    } finally {
        hideLoading();
    }
}

// --- Event Listeners ---
generatePromptBtn.addEventListener('click', generatePrompt);

// Voice Input (Speech Recognition)
voiceInputBtn.addEventListener('click', () => {
    if (voiceRecognitionActive) {
        // If active, stop recognition
        recognition.stop();
        return;
    }

    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        showError("Your browser does not fully support Speech Recognition (e.g., Chrome, Edge, Firefox). Please use text input.");
        return;
    }

    recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();

    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    voiceInputBtn.innerHTML = '<span class="icon">üõë</span> <span class="btn-text">Stop Listening</span>';
    voiceInputBtn.classList.add('active-listening'); // Add class for styling
    voiceInputBtn.disabled = false; // User can click to stop, so don't disable itself
    uploadFileBtn.disabled = true; // Disable file upload while listening
    generatePromptBtn.disabled = true; // Disable generate while listening
    userInput.disabled = true; // Disable manual text input while listening
    clearError();
    userInput.value = ''; // Clear previous text input when starting new voice input.

    voiceRecognitionActive = true;
    recognition.start();

    recognition.onresult = (event) => {
        const speechResult = event.results[0][0].transcript;
        userInput.value = speechResult; // Replace with new speech
        checkGenerateButtonState();
    };

    recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        showError(`Speech recognition error: ${event.error}. Please try again.`);
        // Reset state
        voiceInputBtn.innerHTML = '<span class="icon">üé§</span> <span class="btn-text">Speak Idea</span>';
        voiceInputBtn.classList.remove('active-listening');
        voiceInputBtn.disabled = false;
        uploadFileBtn.disabled = false;
        userInput.disabled = false;
        voiceRecognitionActive = false;
        checkGenerateButtonState();
    };

    recognition.onend = () => {
        // Recognition ended (either by user stop, timeout, or error handled above)
        if (voiceRecognitionActive) { // Only reset if it wasn't an error already handled
            voiceInputBtn.innerHTML = '<span class="icon">üé§</span> <span class="btn-text">Speak Idea</span>';
            voiceInputBtn.classList.remove('active-listening');
            voiceInputBtn.disabled = false;
            uploadFileBtn.disabled = false;
            userInput.disabled = false;
            voiceRecognitionActive = false;
            checkGenerateButtonState();
        }
    };
});


// File Upload
uploadFileBtn.addEventListener('click', () => {
    fileInput.click(); // Programmatically click the hidden file input
});

fileInput.addEventListener('change', async (event) => {
    const files = event.target.files;
    if (files.length === 0) {
        // If user opened dialog but selected no files
        clearFileInputState(); // Clears any previous files or 'No files chosen'
        return;
    }

    clearError(); // Clear previous errors
    clearFileInputState(); // Clear existing files and previews when new ones are selected

    const MAX_FILE_SIZE_MB = 5; // Per file limit
    const processingPromises = [];

    for (const file of files) {
        if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
            showError(`File "${file.name}" is too large (>${MAX_FILE_SIZE_MB}MB). It will be skipped.`);
            continue; // Skip this file but continue to process others
        }

        const isTextFile = file.type.startsWith('text/') ||
                           /\.(txt|md|js|py|json|html|css|xml|csv|log|sh|rb|go|java|cpp|c|h|swift|kt|php|ts|tsx|jsx|scss|less|yaml|ini|cfg|toml|rtf)$/i.test(file.name);
        
        const isImageFile = file.type.startsWith('image/');
        
        const isComplexDocument = /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i.test(file.name);
        const isAudioVideoFile = file.type.startsWith('audio/') || file.type.startsWith('video/');

        if (isAudioVideoFile || isComplexDocument) {
            showError(`Direct content extraction from "${file.name}" (${file.type}) is not fully supported client-side. Please describe its content in the text box for the AI. This file will be skipped.`);
            continue; // Skip this file
        }

        processingPromises.push(new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const fileData = {
                    fileName: file.name,
                    size: file.size
                };

                if (isTextFile) {
                    fileData.type = 'text';
                    fileData.content = e.target.result;
                } else if (isImageFile) {
                    fileData.type = 'image';
                    fileData.content = e.target.result.split(',')[1];
                    fileData.mimeType = file.type;
                }
                addFileToState(fileData);
                resolve();
            };

            reader.onerror = (e) => {
                console.error("File reading error:", e);
                showError(`Failed to read file "${file.name}".`);
                reject(e);
            };

            if (isTextFile) {
                reader.readAsText(file);
            } else if (isImageFile) {
                reader.readAsDataURL(file);
            }
        }));
    }

    try {
        await Promise.allSettled(processingPromises); // Wait for all file processing to finish
    } catch (error) {
        console.error("One or more files encountered an error during processing:", error);
    }
    
    // After all files are processed/skipped, update UI
    renderFilePreviews();
    checkGenerateButtonState();
});


// Copy to Clipboard
copyPromptBtn.addEventListener('click', async () => {
    try {
        await navigator.clipboard.writeText(outputPrompt.value);
        const originalContent = copyPromptBtn.innerHTML;
        copyPromptBtn.innerHTML = '<span class="icon">‚úÖ</span> <span class="btn-text">Copied!</span>';
        setTimeout(() => {
            copyPromptBtn.innerHTML = originalContent;
        }, 2000);
    } catch (err) {
        console.error('Failed to copy text: ', err);
        showError('Failed to copy prompt to clipboard. Please copy manually.');
    }
});


// --- New Prompt / Refresh Functionality ---
function newPromptRefresh() {
    userInput.value = '';
    clearFileInputState(); // Clears attachedFiles, fileInput, fileNameDisplay, filePreview
    outputPrompt.value = '';
    clearError();
    copyPromptBtn.style.display = 'none';
    if (voiceRecognitionActive && recognition) { // Check if recognition object exists
        recognition.stop(); // Stop listening if active
    }
    // Reset voice input button visual state if it was active
    voiceInputBtn.innerHTML = '<span class="icon">üé§</span> <span class="btn-text">Speak Idea</span>';
    voiceInputBtn.classList.remove('active-listening');
    voiceRecognitionActive = false; // Ensure state is false
    userInput.disabled = false; // Re-enable user input
    uploadFileBtn.disabled = false; // Re-enable file upload
    checkGenerateButtonState(); // Update generate button state
}

// Event Listeners for new header buttons
newPromptRefreshBtn.addEventListener('click', newPromptRefresh);
viewHistoryBtn.addEventListener('click', () => {
    renderHistoryModal();
    historyModal.style.display = 'flex'; // Use flex to center the modal
});


// --- History Management ---
const HISTORY_KEY = 'aiPromptHistory';
const MAX_HISTORY_ITEMS = 15; // Limit to prevent local storage bloat

function loadHistoryFromLocalStorage() {
    try {
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
        return history.sort((a, b) => b.timestamp - a.timestamp); // Sort by newest first
    } catch (e) {
        console.error("Failed to load history from local storage:", e);
        return [];
    }
}

function saveHistoryToLocalStorage(history) {
    try {
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
        console.error("Failed to save history to local storage:", e);
        showError("Failed to save prompt to history. Local storage might be full or blocked.");
    }
}

function savePromptToHistory(rawInput, generatedPrompt, attachedFileNames) {
    let history = loadHistoryFromLocalStorage();

    const newEntry = {
        id: generateUniqueId(), // Reuse unique ID generator
        timestamp: Date.now(),
        rawInputText: rawInput,
        generatedPrompt: generatedPrompt,
        attachedFiles: attachedFileNames // Array of file names
    };

    history.unshift(newEntry); // Add to the beginning

    // Trim history to MAX_HISTORY_ITEMS
    if (history.length > MAX_HISTORY_ITEMS) {
        history = history.slice(0, MAX_HISTORY_ITEMS);
    }

    saveHistoryToLocalStorage(history);
}

function renderHistoryModal() {
    const history = loadHistoryFromLocalStorage();
    historyList.innerHTML = ''; // Clear previous entries

    if (history.length === 0) {
        historyList.innerHTML = '<p class="no-history-message">No prompts saved yet. Generate a prompt to see it here!</p>';
        clearHistoryBtn.disabled = true;
        return;
    }

    clearHistoryBtn.disabled = false;

    history.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'history-item';

        const header = document.createElement('div');
        header.className = 'history-item-header';
        const timestamp = new Date(entry.timestamp).toLocaleString();
        header.innerHTML = `<span class="timestamp">${timestamp}</span>`;
        item.appendChild(header);

        const content = document.createElement('div');
        content.className = 'history-item-content';
        content.innerHTML = `
            <p><strong>Your Input:</strong> ${entry.rawInputText.substring(0, 100)}${entry.rawInputText.length > 100 ? '...' : ''}</p>
            <p><strong>Generated Prompt:</strong> ${entry.generatedPrompt.substring(0, 150)}${entry.generatedPrompt.length > 150 ? '...' : ''}</p>
        `;
        if (entry.attachedFiles && entry.attachedFiles.length > 0) {
            content.innerHTML += `<p class="file-note"><strong>Files:</strong> ${entry.attachedFiles.join(', ')} (Note: files are not reloaded)</p>`;
        }
        item.appendChild(content);

        const actions = document.createElement('div');
        actions.className = 'history-item-actions';

        const loadBtn = document.createElement('button');
        loadBtn.className = 'action-btn load-btn';
        loadBtn.textContent = 'Load';
        loadBtn.onclick = () => loadPromptFromHistory(entry.id);
        actions.appendChild(loadBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'action-btn delete-btn';
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => deleteHistoryItem(entry.id);
        actions.appendChild(deleteBtn);

        item.appendChild(actions);
        historyList.appendChild(item);
    });
}

function loadPromptFromHistory(id) {
    const history = loadHistoryFromLocalStorage();
    const entry = history.find(item => item.id === id);

    if (entry) {
        // Clear current state
        newPromptRefresh(); // Resets everything first

        // Populate with history data
        userInput.value = entry.rawInputText;
        outputPrompt.value = entry.generatedPrompt;

        // Files are not reloaded, provide a warning or clear indication
        if (entry.attachedFiles && entry.attachedFiles.length > 0) {
            showError(`Loaded text from history. Note: Original files (${entry.attachedFiles.join(', ')}) are NOT reloaded. Please re-upload if needed to use them.`);
        }
        
        showCopyButton(); // Ensure copy button is visible if output is loaded
        historyModal.style.display = 'none'; // Close modal
        checkGenerateButtonState(); // Update button states
    } else {
        showError("History item not found.");
    }
}

function deleteHistoryItem(id) {
    if (!confirm('Are you sure you want to delete this prompt from history?')) return;
    let history = loadHistoryFromLocalStorage();
    history = history.filter(item => item.id !== id);
    saveHistoryToLocalStorage(history);
    renderHistoryModal(); // Refresh the modal content
}

function clearAllHistory() {
    if (!confirm('Are you sure you want to clear ALL prompt history? This cannot be undone.')) return;
    localStorage.removeItem(HISTORY_KEY);
    renderHistoryModal(); // Refresh the modal content
}

// Event Listeners for History Modal
closeHistoryBtn.addEventListener('click', () => {
    historyModal.style.display = 'none';
});

window.addEventListener('click', (event) => {
    if (event.target === historyModal) {
        historyModal.style.display = 'none';
    }
});

clearHistoryBtn.addEventListener('click', clearAllHistory);


// Event listeners for input changes to enable/disable generate button
userInput.addEventListener('input', checkGenerateButtonState);

// Initial check on page load
checkGenerateButtonState();

/* Import Google Fonts for Space Grotesk and Noto Sans */
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&family=Noto+Sans:wght@400;500;700&display=swap');

/* CSS Variables for a consistent and easily changeable dark theme */
:root {
    --bg-color: #111118; /* Deep indigo/charcoal */
    --primary-accent: #1313ec; /* Vibrant electric blue */
    --primary-accent-hover: #0a0acf; /* Slightly darker blue for hover */
    --primary-accent-dark: #0f0fbf; /* Even darker blue */
    --text-white: #FFFFFF;
    --text-light-grey: #9d9db9; /* For secondary text, placeholders */
    --element-bg: #1c1c27; /* Slightly lighter dark grey for interactive elements */
    --element-bg-hover: #2a2a38; /* For hover states on dark elements */
    --border-dark-grey: #3b3b54;
    --header-border: #282839; /* For the bottom border of the header */
    --error-color: #DC3545; /* Red for errors */
    --success-color: #28A745; /* Green for success */
    --shadow-dark: rgba(0, 0, 0, 0.3); /* Dark shadow */
    --shadow-light-on-dark: rgba(255, 255, 255, 0.05); /* Subtle highlight on dark elements */

    --border-radius-base: 12px;
    --border-radius-small: 8px;
    --padding-base: 25px;
    --gap-base: 25px;
}

/* Universal box-sizing for consistent layout */
*, *::before, *::after {
    box-sizing: border-box;
}

body {
    font-family: 'Noto Sans', sans-serif; /* Body text */
    margin: 0;
    padding: 0;
    background-color: var(--bg-color);
    color: var(--text-white);
    line-height: 1.6;
    display: flex;
    flex-direction: column; /* Ensure full page content flows vertically */
    min-height: 100vh;
    overflow-x: hidden; /* Prevent horizontal scrollbar on body from accidental overflow */
}

main {
    flex-grow: 1; /* Allow main content to take available space */
}

/* Base styles for all sections */
section {
    padding: 80px var(--padding-base); /* Generous vertical padding */
    max-width: 1200px;
    margin: 0 auto;
    text-align: center;
    width: 100%; /* Ensure sections take full available width up to max-width */
}

.section-heading {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 2.5em;
    font-weight: 700;
    color: var(--text-white);
    margin-bottom: 40px;
    text-align: left;
}

.section-text {
    text-align: left;
    max-width: 800px;
    margin: 0 auto;
}
.section-text p {
    font-size: 1.1em;
    color: var(--text-light-grey);
}


/* --- Header (Top Navigation Bar) --- */
.main-header {
    position: sticky; /* Make header sticky */
    top: 0;
    width: 100%;
    background-color: var(--bg-color);
    padding: 15px var(--padding-base);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--header-border);
    z-index: 1000; /* Ensure it stays on top */
}

.main-header .logo {
    display: flex;
    align-items: center;
    gap: 10px;
}

.main-header .logo-icon {
    font-size: 1.8em;
    color: var(--text-white);
}

.main-header .logo-text {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.6em;
    font-weight: 700;
    color: var(--text-white);
}

.main-nav ul {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    gap: 30px;
}

.main-nav a {
    color: var(--text-white);
    text-decoration: none;
    font-weight: 500;
    font-size: 1.05em;
    transition: color 0.3s ease;
}

.main-nav a:hover {
    color: var(--primary-accent);
}

.header-actions {
    display: flex;
    gap: 15px; /* Space between buttons */
    align-items: center;
}

.header-btn {
    padding: 8px 18px; /* Slightly smaller than main buttons */
    font-size: 0.95em;
    font-weight: 500;
    border-radius: 50px; /* Consistent rounded style */
}

#viewHistoryBtn {
    background-color: var(--element-bg);
    color: var(--text-white);
    border: 1px solid var(--border-dark-grey);
}
#viewHistoryBtn:hover {
    background-color: var(--element-bg-hover);
    border-color: var(--primary-accent);
}

/* --- Hero Section --- */
.hero-section {
    /* Example muted background image. Replace with your own. */
    background-image: url('https://images.unsplash.com/photo-1510931215160-c48c66e4a287?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D');
    background-size: cover;
    background-position: center;
    padding: 100px var(--padding-base);
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 80vh; /* Make it take most of the viewport height */
}

.hero-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    /* Dark-to-transparent gradient overlay */
    background: linear-gradient(to bottom, rgba(17, 17, 24, 0.4) 0%, rgba(17, 17, 24, 0.8) 70%, var(--bg-color) 100%);
    z-index: 1;
}

.hero-content {
    position: relative;
    z-index: 2;
    max-width: 900px;
    width: 100%;
    text-align: center;
    background-color: var(--element-bg); /* Card-like background */
    padding: calc(var(--padding-base) * 1.5);
    border-radius: var(--border-radius-base);
    box-shadow: 0 10px 30px var(--shadow-dark);
    border: 1px solid var(--border-dark-grey);
}

.hero-content h1 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 3.5em;
    font-weight: 700;
    color: var(--text-white);
    margin-bottom: 15px;
    line-height: 1.2;
}

.hero-content h2 {
    font-family: 'Noto Sans', sans-serif;
    font-size: 1.4em;
    font-weight: 400;
    color: var(--text-light-grey);
    margin-bottom: 40px;
}

/* Prompt Input Area - includes main input, controls, preview, output */
.prompt-input-area {
    margin-top: 30px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.input-field-group {
    display: flex;
    align-items: stretch; /* Stretch textarea to match button height */
    background-color: var(--element-bg);
    border: 1px solid var(--border-dark-grey);
    border-radius: var(--border-radius-base);
    overflow: hidden;
    margin-bottom: 15px;
}

.input-field-group .icon.search-icon {
    padding: 0 15px;
    display: flex;
    align-items: center;
    font-size: 1.5em;
    color: var(--text-light-grey);
    flex-shrink: 0; /* Prevent icon from shrinking */
}

textarea#userInput {
    flex-grow: 1;
    min-height: 120px; /* Adjusted height for hero section */
    padding: 15px 0; /* No left/right padding due to icon/button */
    border: none; /* Remove default border */
    background-color: transparent;
    color: var(--text-white);
    font-family: 'Noto Sans', sans-serif;
    font-size: 1.1em;
    resize: vertical;
    outline: none; /* Remove focus outline */
}

textarea#userInput::placeholder {
    color: var(--text-light-grey);
    opacity: 0.7;
}

/* Primary Button Styling */
.primary-btn {
    background-color: var(--primary-accent);
    color: var(--text-white);
    box-shadow: 0 4px 10px rgba(19, 19, 236, 0.3);
    align-self: center; /* Center the button in the container */
    border: none;
    border-radius: var(--border-radius-small); /* Default radius for standalone buttons */
    font-size: 1.05em;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px; /* Spacing between icon and text */
}
.primary-btn:hover {
    background-color: var(--primary-accent-hover);
    transform: translateY(-2px); /* Lift effect on hover */
    box-shadow: 0 6px 15px rgba(19, 19, 236, 0.4);
}
.primary-btn:active {
    transform: translateY(0); /* Reset on click */
    box-shadow: 0 2px 5px rgba(19, 19, 236, 0.3);
}
.primary-btn:disabled {
    background-color: #555;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.generate-btn {
    padding: 10px 25px;
    font-size: 1.1em;
    border-radius: 0 var(--border-radius-base) var(--border-radius-base) 0; /* Rounded only on right */
    flex-shrink: 0; /* Prevent button from shrinking */
    box-shadow: none; /* Remove extra shadow for integrated button */
}

.generate-btn:hover {
    background-color: var(--primary-accent-hover);
    transform: none; /* No transform on hover for integrated button */
}
.generate-btn:active {
    background-color: var(--primary-accent-dark);
}


.additional-input-controls {
    display: flex;
    gap: 15px;
    justify-content: flex-start; /* Align to left */
    flex-wrap: wrap; /* Allow wrapping */
}

/* Secondary Action Button Styling */
button.action-btn {
    background-color: var(--element-bg);
    color: var(--text-white);
    border: 1px solid var(--border-dark-grey);
    padding: 10px 20px;
    border-radius: var(--border-radius-small);
    font-size: 0.95em;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
    cursor: pointer;
    font-weight: 500;
}

button.action-btn:hover {
    background-color: var(--element-bg-hover);
    border-color: var(--primary-accent);
    transform: translateY(-2px);
}
button.action-btn:active {
    transform: translateY(0);
}
button.action-btn:disabled {
    background-color: #282839;
    border-color: #3b3b54;
    color: #666;
    cursor: not-allowed;
    transform: none;
}

/* Style for voice input button when active */
button#voiceInputBtn.active-listening {
    background-color: var(--error-color); /* Use red to indicate active recording */
    border-color: var(--error-color);
}
button#voiceInputBtn.active-listening:hover {
    background-color: #e04a5c; /* Slightly lighter red */
    border-color: #e04a5c;
}


.file-upload-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-grow: 1; /* Allow wrapper to take available space */
    max-width: 100%; /* Prevent overflow */
}

.file-name-display {
    flex: 1 1 0; /* Allow it to grow, shrink, and have a base of 0 */
    min-width: 0; /* Essential for text-overflow: ellipsis to work */
    font-size: 0.9em;
    color: var(--text-light-grey);
    white-space: nowrap; /* Prevent wrapping */
    overflow: hidden;
    text-overflow: ellipsis; /* Show ellipsis if text overflows */
}

.file-info-text {
    color: var(--text-light-grey);
    display: block;
    margin-top: 5px;
    font-size: 0.85em;
    text-align: left;
}

.file-preview {
    margin-top: 15px;
    padding: 15px;
    background-color: var(--element-bg);
    border: 1px dashed var(--border-dark-grey);
    border-radius: var(--border-radius-base);
    display: flex;
    flex-wrap: wrap; /* Allow multiple previews to wrap */
    gap: 15px;
    justify-content: flex-start;
    align-items: flex-start;
    max-height: 250px; /* Limit height for multiple previews */
    overflow-y: auto; /* Enable scrolling if too many files */
    display: none; /* Hidden by default */
}

.file-preview.active { /* Class to explicitly show it when files exist */
    display: flex;
}

.file-preview-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    max-width: 100px; /* Limit width for individual items */
    text-align: center;
    position: relative;
    padding: 5px;
    border: 1px solid var(--border-dark-grey);
    border-radius: var(--border-radius-small);
    background-color: #2a2a38;
}

.file-preview-item img {
    max-width: 80px;
    max-height: 80px;
    object-fit: contain;
    border-radius: 4px;
}
.file-preview-item .file-name, .file-preview-item .file-size {
    font-size: 0.75em;
    color: var(--text-light-grey);
    word-break: break-all; /* Break long file names */
}
.file-preview-item .remove-file-btn {
    position: absolute;
    top: -8px;
    right: -8px;
    background-color: var(--error-color);
    color: var(--text-white);
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 0.7em;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    line-height: 1;
    padding: 0;
    z-index: 10;
}
.file-preview-item .remove-file-btn:hover {
    background-color: #ff4d4d;
}

/* Loading Indicator Styling */
.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin: 25px 0;
    color: var(--primary-accent);
    font-size: 1.2em;
    font-weight: 600;
}

.spinner {
    border: 4px solid rgba(19, 19, 236, 0.3); /* Blue with transparency */
    border-top: 4px solid var(--primary-accent);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Error Message Styling */
.error-message {
    color: var(--error-color);
    background-color: rgba(220, 53, 69, 0.15); /* Light red background with transparency */
    border: 1px solid var(--error-color);
    padding: 12px;
    border-radius: var(--border-radius-small);
    margin: 25px 0;
    font-weight: 500;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 10px;
}

.error-message::before {
    content: '‚ö†Ô∏è'; /* Warning emoji for visual emphasis */
    font-size: 1.2em;
    flex-shrink: 0; /* Prevent emoji from shrinking */
}

/* Output Section Styling */
.output-section {
    margin-top: 30px;
    text-align: left;
}
.output-section .section-title {
    display: block;
    font-size: 1.2em;
    font-weight: 500;
    color: var(--text-white);
    margin-bottom: 15px;
}
textarea#outputPrompt {
    background-color: var(--element-bg-hover); /* Slightly darker for output */
    border: 1px solid var(--primary-accent); /* Blue border for generated content */
    border-radius: var(--border-radius-base);
    color: var(--text-white);
    min-height: 180px;
    width: 100%;
    padding: 15px;
    font-family: 'Noto Sans', sans-serif;
    font-size: 1.05em;
    resize: vertical;
    box-sizing: border-box;
    transition: border-color 0.3s ease;
}

.output-section button#copyPromptBtn {
    margin-top: 15px;
    float: right; /* Align to right */
    background-color: var(--element-bg);
    border-color: var(--border-dark-grey);
    color: var(--text-white);
}
.output-section button#copyPromptBtn:hover {
    border-color: var(--primary-accent);
}

/* --- Example Prompts Section --- */
.section-cards {
    padding-top: var(--padding-base); /* Adjust padding */
    padding-bottom: var(--padding-base);
}
.example-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 25px;
    margin-top: 40px;
}

.example-card {
    background-color: var(--element-bg);
    border: 1px solid var(--border-dark-grey);
    border-radius: var(--border-radius-base);
    padding: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    text-align: left;
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

.example-card:hover {
    background-color: var(--element-bg-hover);
    border-color: var(--primary-accent);
}

.example-card .icon {
    font-size: 1.8em;
    color: var(--primary-accent);
    flex-shrink: 0;
}

.example-card p {
    font-weight: 500;
    color: var(--text-white);
    margin: 0;
    font-size: 1.1em;
}

/* --- Footer --- */
.main-footer {
    background-color: var(--bg-color);
    padding: 40px var(--padding-base);
    border-top: 1px solid var(--header-border);
    text-align: center;
    margin-top: auto; /* Push footer to the bottom */
}

.footer-nav ul {
    list-style: none;
    margin: 0 0 20px 0;
    padding: 0;
    display: flex;
    justify-content: center;
    gap: 30px;
    flex-wrap: wrap;
}

.footer-nav a {
    color: var(--text-light-grey);
    text-decoration: none;
    font-size: 0.95em;
    transition: color 0.3s ease;
}

.footer-nav a:hover {
    color: var(--primary-accent);
}

.copyright {
    color: var(--text-light-grey);
    font-size: 0.9em;
    margin: 0;
}

/* --- Modal Styling for History --- */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1001; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
    justify-content: center;
    align-items: center;
    padding: 20px;
}

.modal-content {
    background-color: var(--element-bg);
    margin: auto;
    padding: var(--padding-base);
    border: 1px solid var(--border-dark-grey);
    border-radius: var(--border-radius-base);
    width: 90%;
    max-width: 700px;
    position: relative;
    box-shadow: 0 10px 30px var(--shadow-dark);
    text-align: left;
    max-height: 90vh; /* Limit height */
    display: flex;
    flex-direction: column;
}

.modal-title {
    font-family: 'Space Grotesk', sans-serif;
    color: var(--text-white);
    font-size: 2em;
    margin-top: 0;
    margin-bottom: 25px;
}

.close-button {
    color: var(--text-light-grey);
    font-size: 2em;
    font-weight: bold;
    position: absolute;
    top: 15px;
    right: 25px;
    cursor: pointer;
    transition: color 0.3s ease;
}

.close-button:hover,
.close-button:focus {
    color: var(--text-white);
    text-decoration: none;
    cursor: pointer;
}

.history-list {
    flex-grow: 1; /* Allow list to take available space */
    overflow-y: auto; /* Scrollable if content exceeds height */
    max-height: calc(90vh - 200px); /* Adjust based on other modal content */
    margin-bottom: 20px;
    padding-right: 10px; /* For scrollbar */
}
/* Scrollbar styling for dark theme */
.history-list::-webkit-scrollbar {
    width: 8px;
}
.history-list::-webkit-scrollbar-track {
    background: #3b3b54;
    border-radius: 4px;
}
.history-list::-webkit-scrollbar-thumb {
    background: var(--primary-accent);
    border-radius: 4px;
}
.history-list::-webkit-scrollbar-thumb:hover {
    background: var(--primary-accent-hover);
}


.history-item {
    background-color: var(--bg-color);
    border: 1px solid var(--border-dark-grey);
    border-radius: var(--border-radius-small);
    padding: 15px;
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    transition: background-color 0.2s ease;
}

.history-item:hover {
    background-color: #1a1a20;
}

.history-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9em;
    color: var(--text-light-grey);
    flex-wrap: wrap; /* Allow wrapping on small screens */
}

.history-item-header .timestamp {
    font-weight: 500;
}

.history-item-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.history-item-content p {
    margin: 0;
    font-size: 0.95em;
    color: var(--text-white);
}

.history-item-content strong {
    color: var(--primary-accent);
}

.history-item-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
    justify-content: flex-end; /* Align buttons to the right */
    flex-wrap: wrap;
}

.history-item-actions button {
    padding: 8px 15px;
    font-size: 0.85em;
    border-radius: var(--border-radius-small);
    font-weight: 500;
}

.history-item-actions .load-btn {
    background-color: var(--primary-accent);
    color: var(--text-white);
}
.history-item-actions .load-btn:hover {
    background-color: var(--primary-accent-hover);
}

.history-item-actions .delete-btn {
    background-color: var(--error-color);
    color: var(--text-white);
}
.history-item-actions .delete-btn:hover {
    background-color: #e04a5c;
}

.modal-actions {
    margin-top: 20px;
    text-align: right;
}
.modal-actions .action-btn {
    background-color: var(--element-bg-hover);
    color: var(--text-white);
    border: 1px solid var(--border-dark-grey);
}
.modal-actions .action-btn:hover {
    border-color: var(--primary-accent);
}

.no-history-message {
    color: var(--text-light-grey);
    text-align: center;
    margin-top: 30px;
    font-style: italic;
}

/* --- Responsive Adjustments --- */
@media (max-width: 992px) {
    .main-header .main-nav {
        display: none; /* Hide main nav on smaller screens */
    }
    .main-header {
        flex-direction: row; /* Keep logo and actions on same row */
        justify-content: space-between;
        align-items: center;
    }
    .main-header .header-actions {
        order: 3; /* Push actions to the right */
    }

    .hero-content h1 {
        font-size: 3em;
    }
    .hero-content h2 {
        font-size: 1.2em;
    }
    .section-heading {
        font-size: 2em;
    }
}

@media (max-width: 768px) {
    .main-header {
        flex-wrap: wrap; /* Allow header elements to wrap */
        justify-content: center;
        gap: 15px;
    }
    .main-header .logo, .main-header .header-actions {
        width: 100%;
        justify-content: center;
        display: flex;
    }
    .main-header .header-actions {
        flex-wrap: wrap;
        gap: 10px;
    }
    .header-btn {
        flex-grow: 1;
        max-width: 180px;
    }
    
    .hero-section {
        padding: 80px var(--padding-base);
    }
    .hero-content {
        padding: var(--padding-base);
    }
    .hero-content h1 {
        font-size: 2.5em;
    }
    .hero-content h2 {
        font-size: 1.1em;
    }
    .input-field-group {
        flex-direction: column;
        border-radius: var(--border-radius-base);
    }
    .input-field-group .icon.search-icon {
        display: none; /* Hide icon on small screens for vertical stack */
    }
    textarea#userInput {
        border-radius: var(--border-radius-base) var(--border-radius-base) 0 0;
        min-height: 100px;
        padding: 15px;
        text-align: center;
        width: 100%; /* Ensure it takes full width when stacked */
    }
    .generate-btn {
        width: 100%;
        border-radius: 0 0 var(--border-radius-base) var(--border-radius-base);
        padding: 15px 25px;
    }
    .additional-input-controls {
        flex-direction: column;
        align-items: stretch;
    }
    .file-upload-wrapper {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
    }
    .file-upload-wrapper button {
        width: 100%;
    }
    .file-name-display {
        max-width: 100%; /* Ensure it doesn't cause overflow */
        text-align: left;
    }
    button.action-btn {
        width: 100%; /* Make action buttons full width when stacked */
    }
    .output-section button#copyPromptBtn {
        float: none;
        width: 100%;
    }
    .section-heading {
        font-size: 1.8em;
    }
    .section-text p {
        font-size: 1em;
    }
    .footer-nav ul {
        flex-direction: column;
        gap: 15px;
    }

    /* Modal responsiveness */
    .modal-content {
        padding: 20px;
        width: 95%;
    }
    .modal-title {
        font-size: 1.5em;
    }
    .close-button {
        font-size: 1.8em;
        top: 10px;
        right: 15px;
    }
    .history-item {
        padding: 12px;
    }
    .history-item-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
    }
    .history-item-actions {
        justify-content: flex-start;
    }
}

@media (max-width: 480px) {
    body {
        font-size: 0.9em;
    }
    .main-header {
        padding: 10px 15px;
    }
    .main-header .logo-text {
        font-size: 1.4em;
    }
    .header-btn {
        padding: 8px 15px;
        font-size: 0.9em;
    }
    .hero-section {
        padding: 60px 15px;
    }
    .hero-content {
        padding: 20px;
    }
    .hero-content h1 {
        font-size: 2em;
    }
    .hero-content h2 {
        font-size: 1em;
        margin-bottom: 25px;
    }
    textarea#userInput {
        min-height: 80px;
        font-size: 1em;
    }
    .generate-btn {
        font-size: 1em;
        padding: 12px 20px;
    }
    .file-info-text {
        font-size: 0.8em;
    }
    .file-preview {
        max-height: 200px;
        gap: 10px;
        padding: 10px;
    }
    .file-preview-item {
        max-width: 80px;
    }
    .file-preview-item img {
        max-width: 60px;
        max-height: 60px;
    }
    .loading span, .error-message {
        font-size: 0.9em;
    }
    .spinner {
        width: 25px;
        height: 25px;
    }
    textarea#outputPrompt {
        min-height: 150px;
        font-size: 0.95em;
    }
    .section-heading {
        font-size: 1.5em;
        margin-bottom: 25px;
    }
    .example-grid {
        gap: 15px;
    }
    .example-card {
        padding: 15px;
        flex-direction: column;
        text-align: center;
    }
    .example-card .icon {
        font-size: 1.5em;
    }
    .example-card p {
        font-size: 0.95em;
    }
    .footer-nav a {
        font-size: 0.85em;
    }
    .copyright {
        font-size: 0.8em;
    }
}

-----------------------------------------------------------------------------------------------------------

